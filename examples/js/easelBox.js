// Generated by CoffeeScript 1.3.3
(function() {
  var PIXELS_PER_METER,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.EaselBoxObject = (function() {
    var getType;

    function EaselBoxObject(easelObj, box2dShape, options) {
      var density, friction, restitution;
      this.easelObj = easelObj;
      density = (options && options.density) || 1;
      friction = (options && options.friction) || 0.5;
      restitution = (options && options.restitution) || 0.2;
      this.fixDef = new Box2D.Dynamics.b2FixtureDef;
      this.fixDef.density = density;
      this.fixDef.friction = friction;
      this.fixDef.restitution = restitution;
      this.fixDef.shape = box2dShape;
      this.bodyDef = new Box2D.Dynamics.b2BodyDef;
      this.body = null;
    }

    EaselBoxObject.prototype.update = function() {
      this.easelObj.x = this.body.GetPosition().x * PIXELS_PER_METER;
      this.easelObj.y = this.body.GetPosition().y * PIXELS_PER_METER;
      return this.easelObj.rotation = this.body.GetAngle() * (180 / Math.PI);
    };

    EaselBoxObject.prototype.setType = function(type) {
      return this.body.SetType(getType(type));
    };

    EaselBoxObject.prototype.setState = function(options) {
      var angleDegrees, angleRadians, angularVelDegrees, angularVelRadians, xMeters, xPixels, xVelMeters, xVelPixels, yMeters, yPixels, yVelMeters, yVelPixels;
      if (options && options.xPixels) {
        xPixels = options.xPixels;
        xMeters = xPixels / PIXELS_PER_METER;
      } else if (options && options.Xmeters) {
        xMeters = options.Xmeters;
        xPixels = xMeters * PIXELS_PER_METER;
      } else {
        xMeters = 0;
        xPixels = 0;
      }
      if (options && options.yPixels) {
        yPixels = options.yPixels;
        yMeters = yPixels / PIXELS_PER_METER;
      } else if (options && options.Xmeters) {
        yMeters = options.Ymeters;
        yPixels = YMeters * PIXELS_PER_METER;
      } else {
        yMeters = 0;
        yPixels = 0;
      }
      if (options && options.xVelPixels) {
        xVelPixels = options.xVelPixels;
        xVelMeters = xVelPixels / PIXELS_PER_METER;
      } else if (options && options.xVelMeters) {
        xVelMeters = options.xVelMeters;
        xVelPixels = xVelMeters * PIXELS_PER_METER;
      } else {
        xVelMeters = 0;
        xVelPixels = 0;
      }
      if (options && options.yVelPixels) {
        yVelPixels = options.yVelPixels;
        yVelMeters = yVelPixels / PIXELS_PER_METER;
      } else if (options && options.yVelMeters) {
        yVelMeters = options.yVelMeters;
        yVelPixels = yVelMeters * PIXELS_PER_METER;
      } else {
        yVelMeters = 0;
        yVelPixels = 0;
      }
      if (options && options.angleDegrees) {
        angleDegrees = options.angleDegrees;
        angleRadians = Math.PI * angleDegrees / 180;
      } else if (options && options.angleRadians) {
        angleRadians = options.angleRadians;
        angleDegrees = 180 * angleRadians / Math.PI;
      } else {
        angleRadians = 0;
        angleDegrees = 0;
      }
      if (options && options.angularVelRadians) {
        angularVelRadians = options.angularVelRadians;
        angularVelDegrees = 180 * angularVelRadians / Math.PI;
      } else if (options && options.angularVelDegrees) {
        angularVelDegrees = options.angularVelDegrees;
        angularVelRadians = Math.PI * angularVelDegrees / 180;
      } else {
        angularVelDegrees = 0;
        angularVelRadians = 0;
      }
      this.easelObj.x = xPixels;
      this.easelObj.y = yPixels;
      this.easelObj.rotation = angleDegrees;
      this.body.GetPosition().x = xMeters;
      this.body.GetPosition().y = yMeters;
      this.body.SetAngle(angleRadians);
      this.body.SetAngularVelocity(angularVelRadians);
      return this.body.SetLinearVelocity(new Box2D.Common.Math.b2Vec2(xVelMeters, yVelMeters));
    };

    getType = function(type) {
      if ('dynamic' === type) {
        return Box2D.Dynamics.b2Body.b2_dynamicBody;
      } else if ('static' === type) {
        return Box2D.Dynamics.b2Body.b2_staticBody;
      } else if ('kinematic' === type) {
        return Box2D.Dynamics.b2Body.b2_kinematicBody;
      }
    };

    return EaselBoxObject;

  })();

  window.EaselBoxLandscapeRectangle = (function(_super) {

    __extends(EaselBoxLandscapeRectangle, _super);

    function EaselBoxLandscapeRectangle(options) {
      var box2dShape, hillVector, object, x1, x2, x3, x4, y1, y2, y3, y4;
      object = new Shape();
      hillVector = new Vector(4);
      x1 = options.bottom_left_corner.x / PIXELS_PER_METER;
      y1 = options.bottom_left_corner.y / PIXELS_PER_METER;
      x2 = options.top_left_corner.x / PIXELS_PER_METER;
      y2 = options.top_left_corner.y / PIXELS_PER_METER;
      x3 = options.top_right_corner.x / PIXELS_PER_METER;
      y3 = options.top_right_corner.y / PIXELS_PER_METER;
      x4 = options.bottom_right_corner.x / PIXELS_PER_METER;
      y4 = options.bottom_right_corner.y / PIXELS_PER_METER;
      hillVector[0] = new Box2D.Common.Math.b2Vec2(x1, y1);
      hillVector[1] = new Box2D.Common.Math.b2Vec2(x2, y2);
      hillVector[2] = new Box2D.Common.Math.b2Vec2(x3, y3);
      hillVector[3] = new Box2D.Common.Math.b2Vec2(x4, y4);
      box2dShape = new Box2D.Collision.Shapes.b2PolygonShape.AsArray(hillVector, 4);
      EaselBoxLandscapeRectangle.__super__.constructor.call(this, object, box2dShape, options);
    }

    return EaselBoxLandscapeRectangle;

  })(EaselBoxObject);

  window.EaselBoxMonkey = (function() {
    var getType;

    function EaselBoxMonkey(callingObject, options) {
      var density, friction, restitution;
      this.callingObject = callingObject;
      this.voffset = options.voffset;
      this.spriteSheet = options.SpriteSheet;
      this.easelObj = new BitmapAnimation(this.spriteSheet);
      this.easelObj.gotoAndPlay("standby");
      this.easelObj.name = "monkey_idle";
      this.easelObj.currentFrame = 0;
      this.easelObj.x = options.xPixels;
      this.easelObj.y = options.yPixels;
      this.easelObj.regX = options.regX;
      this.easelObj.regY = options.regY;
      this.easelObj.scaleX = options.scaleX;
      this.easelObj.scaleY = options.scaleY;
      this.easelObj.globalRegX = options.xPixels;
      this.easelObj.globalRegY = options.yPixels;
      this.easelObj.angle = 0;
      this.prev_angle = 0;
      this.size_head_meters = options.size_head / PIXELS_PER_METER;
      this.size_torso_meters = options.size_torso / PIXELS_PER_METER;
      this.size_lowerbody_meters = options.size_lowerbody / PIXELS_PER_METER;
      this.monkeyhead = new Box2D.Collision.Shapes.b2PolygonShape.AsBox(this.size_head_meters, this.size_head_meters);
      this.monkeytorso = new Box2D.Collision.Shapes.b2PolygonShape.AsBox(this.size_torso_meters, this.size_torso_meters);
      this.monkeylowerbody = new Box2D.Collision.Shapes.b2PolygonShape.AsBox(this.size_lowerbody_meters, this.size_lowerbody_meters);
      density = (options && options.density) || 1;
      friction = (options && options.friction) || 0.5;
      restitution = (options && options.restitution) || 0.2;
      this.fixDefHead = new Box2D.Dynamics.b2FixtureDef;
      this.fixDefHead.density = density;
      this.fixDefHead.friction = friction;
      this.fixDefHead.restitution = restitution;
      this.fixDefHead.shape = this.monkeyhead;
      this.bodyDefHead = new Box2D.Dynamics.b2BodyDef;
      this.headbody = null;
      this.fixDefTorso = new Box2D.Dynamics.b2FixtureDef;
      this.fixDefTorso.density = density;
      this.fixDefTorso.friction = friction;
      this.fixDefTorso.restitution = restitution;
      this.fixDefTorso.shape = this.monkeytorso;
      this.bodyDefTorso = new Box2D.Dynamics.b2BodyDef;
      this.torsobody = null;
      this.fixDefLowerbody = new Box2D.Dynamics.b2FixtureDef;
      this.fixDefLowerbody.density = density;
      this.fixDefLowerbody.friction = friction;
      this.fixDefLowerbody.restitution = restitution;
      this.fixDefLowerbody.shape = this.monkeylowerbody;
      this.bodyDefLowerbody = new Box2D.Dynamics.b2BodyDef;
      this.lowerbodybody = null;
      this.headtorsoweldJointDef = new Box2D.Dynamics.Joints.b2WeldJointDef();
      this.torsolowerbodyweldJointDef = new Box2D.Dynamics.Joints.b2WeldJointDef();
    }

    EaselBoxMonkey.prototype.removeActionListeners = function() {
      var _this = this;
      return this.easelObj.onPress = function(eventPress) {};
    };

    EaselBoxMonkey.prototype.addActionListeners = function() {
      var _this = this;
      return this.easelObj.onPress = function(eventPress) {
        _this.easelObj.angle = _this.prev_angle;
        _this.easelObj.gotoAndPlay("approachbazooka");
        eventPress.onMouseMove = function(event) {
          _this.easelObj.angle = _this.prev_angle + Math.PI / 2 - Math.atan2(_this.easelObj.globalRegY - event.stageY, event.stageX - _this.easelObj.globalRegX) - Math.atan2(eventPress.stageX - _this.easelObj.globalRegX, _this.easelObj.globalRegY - eventPress.stageY);
          return _this.setState({
            angleRadians: _this.easelObj.angle,
            xPixels: _this.easelObj.x,
            yPixels: _this.easelObj.y
          });
        };
        return eventPress.onMouseUp = function(event) {
          var beta, d, theta, x, xm, y, ym;
          _this.prev_angle = _this.easelObj.angle;
          xm = (173 - 33) * 1.0 + 75;
          ym = (_this.voffset - 75) - (165 - 15 - (165 - 100)) * 1;
          theta = Math.atan2(_this.easelObj.globalRegY - ym, xm - _this.easelObj.globalRegX);
          beta = Math.PI / 2 - theta - _this.easelObj.angle * -1;
          d = (_this.easelObj.globalRegY - ym) / Math.sin(theta);
          x = d * Math.sin(beta) + _this.easelObj.globalRegX;
          y = _this.easelObj.globalRegY - d * Math.cos(beta);
          _this.easelObj.gotoAndPlay("shoot");
          _this.removeActionListeners();
          return _this.callingObject.shootBanana(x, y, _this.easelObj.angle * -1);
        };
      };
    };

    EaselBoxMonkey.prototype.update = function() {};

    EaselBoxMonkey.prototype.ApplyForce = function(worldgravity) {
      this.headbody.ApplyForce(this.headbody.GetMass() * -worldgravity, this.headbody.GetWorldCenter());
      this.torsobody.ApplyForce(this.torsobody.GetMass() * -worldgravity, this.torsobody.GetWorldCenter());
      return this.lowerbodybody.ApplyForce(this.lowerbodybody.GetMass() * -worldgravity, this.lowerbodybody.GetWorldCenter());
    };

    EaselBoxMonkey.prototype.setType = function(type) {
      this.headbody.SetType(getType(type));
      this.torsobody.SetType(getType(type));
      return this.lowerbodybody.SetType(getType(type));
    };

    EaselBoxMonkey.prototype.setState = function(options) {
      var angleDegrees, angleRadians, angularVelDegrees, angularVelRadians, xMeters, xPixels, xVelMeters, xVelPixels, yMeters, yPixels, yVelMeters, yVelPixels;
      if (options && options.xPixels) {
        xPixels = options.xPixels;
        xMeters = xPixels / PIXELS_PER_METER;
      } else if (options && options.Xmeters) {
        xMeters = options.Xmeters;
        xPixels = xMeters * PIXELS_PER_METER;
      } else {
        xMeters = 0;
        xPixels = 0;
      }
      if (options && options.yPixels) {
        yPixels = options.yPixels;
        yMeters = yPixels / PIXELS_PER_METER;
      } else if (options && options.Xmeters) {
        yMeters = options.Ymeters;
        yPixels = YMeters * PIXELS_PER_METER;
      } else {
        yMeters = 0;
        yPixels = 0;
      }
      if (options && options.xVelPixels) {
        xVelPixels = options.xVelPixels;
        xVelMeters = xVelPixels / PIXELS_PER_METER;
      } else if (options && options.xVelMeters) {
        xVelMeters = options.xVelMeters;
        xVelPixels = xVelMeters * PIXELS_PER_METER;
      } else {
        xVelMeters = 0;
        xVelPixels = 0;
      }
      if (options && options.yVelPixels) {
        yVelPixels = options.yVelPixels;
        yVelMeters = yVelPixels / PIXELS_PER_METER;
      } else if (options && options.yVelMeters) {
        yVelMeters = options.yVelMeters;
        yVelPixels = yVelMeters * PIXELS_PER_METER;
      } else {
        yVelMeters = 0;
        yVelPixels = 0;
      }
      if (options && options.angleDegrees) {
        angleDegrees = options.angleDegrees;
        angleRadians = Math.PI * angleDegrees / 180;
      } else if (options && options.angleRadians) {
        angleRadians = options.angleRadians;
        angleDegrees = 180 * angleRadians / Math.PI;
      } else {
        angleRadians = 0;
        angleDegrees = 0;
      }
      if (options && options.angularVelRadians) {
        angularVelRadians = options.angularVelRadians;
        angularVelDegrees = 180 * angularVelRadians / Math.PI;
      } else if (options && options.angularVelDegrees) {
        angularVelDegrees = options.angularVelDegrees;
        angularVelRadians = Math.PI * angularVelDegrees / 180;
      } else {
        angularVelDegrees = 0;
        angularVelRadians = 0;
      }
      this.easelObj.x = xPixels;
      this.easelObj.y = yPixels;
      this.easelObj.rotation = angleDegrees;
      this.headbody.GetPosition().x = xMeters;
      this.headbody.GetPosition().y = yMeters - this.size_torso_meters - this.size_head_meters - 0.1 - 4;
      this.headbody.SetAngle(angleRadians);
      this.headbody.SetAngularVelocity(angularVelRadians);
      this.headbody.SetLinearVelocity(new Box2D.Common.Math.b2Vec2(xVelMeters, yVelMeters));
      this.torsobody.GetPosition().x = xMeters;
      this.torsobody.GetPosition().y = yMeters - 4;
      this.torsobody.SetAngle(angleRadians);
      this.torsobody.SetAngularVelocity(angularVelRadians);
      this.torsobody.SetLinearVelocity(new Box2D.Common.Math.b2Vec2(xVelMeters, yVelMeters));
      this.lowerbodybody.GetPosition().x = xMeters;
      this.lowerbodybody.GetPosition().y = yMeters + this.size_torso_meters + this.size_lowerbody_meters + 0.1 - 4;
      this.lowerbodybody.SetAngle(angleRadians);
      this.lowerbodybody.SetAngularVelocity(angularVelRadians);
      return this.lowerbodybody.SetLinearVelocity(new Box2D.Common.Math.b2Vec2(xVelMeters, yVelMeters));
    };

    getType = function(type) {
      if ('dynamic' === type) {
        return Box2D.Dynamics.b2Body.b2_dynamicBody;
      } else if ('static' === type) {
        return Box2D.Dynamics.b2Body.b2_staticBody;
      } else if ('kinematic' === type) {
        return Box2D.Dynamics.b2Body.b2_kinematicBody;
      }
    };

    return EaselBoxMonkey;

  })();

  PIXELS_PER_METER = 22;

  window.EaselBoxWorld = (function() {
    var minFPS;

    minFPS = 10;

    function EaselBoxWorld(callingObj, frameRate, canvas, debugCanvas, gravityX, gravityY, pixelsPerMeter) {
      var debugDraw;
      this.callingObj = callingObj;
      this.pixelsPerMeter = pixelsPerMeter;
      PIXELS_PER_METER = this.pixelsPerMeter;
      Ticker.addListener(this);
      Ticker.setFPS(frameRate);
      this.box2dWorld = new Box2D.Dynamics.b2World(new Box2D.Common.Math.b2Vec2(gravityX, gravityY), true);
      this.contactlistener = new EaselBoxContactListener();
      this.box2dWorld.SetContactListener(this.contactlistener);
      this.banana = null;
      this.easelStage = new Stage(canvas);
      this.objects = [];
      debugDraw = new Box2D.Dynamics.b2DebugDraw();
      debugDraw.SetSprite(debugCanvas.getContext("2d"));
      debugDraw.SetDrawScale(this.pixelsPerMeter);
      debugDraw.SetFillAlpha(0.3);
      debugDraw.SetLineThickness(2.0);
      debugDraw.SetFlags(Box2D.Dynamics.b2DebugDraw.e_shapeBit | Box2D.Dynamics.b2DebugDraw.e_jointBit | Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit);
      this.box2dWorld.SetDebugDraw(debugDraw);
    }

    EaselBoxWorld.prototype.addLandscape = function(options) {
      var bound, firstElement, i, iter, iterations, left_idx, max, max_width, max_y, max_y_idx, midpoint_index, midpoint_x, midpoint_y, min, min_width, queue, r, right_idx, ticks, tinyRectangle, x0, x1, x2, y0, y1, y2, _i, _ref, _results,
        _this = this;
      this.flatLand = 40;
      this.height_offset = options.vertical_offset;
      min_width = 0;
      max_width = options.width;
      iterations = options.iterations;
      r = options.smoothness;
      this.height = options.height;
      bound = (function() {

        function bound(min_idx, max_idx, iteration) {
          this.min_idx = min_idx;
          this.max_idx = max_idx;
          this.iteration = iteration;
        }

        return bound;

      })();
      min = -80;
      max = 50;
      ticks = Math.pow(2, iterations);
      this.vpoints_vector = new Array(ticks + 1);
      this.vpoints_vector[0] = new Array(2);
      this.vpoints_vector[ticks] = new Array(2);
      this.vpoints_vector[0][0] = min_width;
      this.vpoints_vector[0][1] = this.height_offset;
      this.vpoints_vector[ticks][0] = max_width;
      this.vpoints_vector[ticks][1] = this.height_offset;
      queue = [];
      queue.push(new bound(0, ticks, 1));
      while (queue.length > 0) {
        firstElement = queue.shift();
        left_idx = firstElement.min_idx;
        right_idx = firstElement.max_idx;
        iter = firstElement.iteration;
        if (right_idx - left_idx > 1) {
          midpoint_x = (this.vpoints_vector[right_idx][0] + this.vpoints_vector[left_idx][0]) / 2;
          midpoint_y = (this.vpoints_vector[right_idx][1] + this.vpoints_vector[left_idx][1]) / 2;
          if (iter > 1) {
            min = min * Math.pow(2, -r);
            max = max * Math.pow(2, -r);
          }
          if (iter === 1) {
            midpoint_y = midpoint_y + Math.random() * (-100 - 5 * min) + 5 * min;
          } else {
            midpoint_y = midpoint_y + Math.random() * (max - min) + min;
          }
          midpoint_index = (left_idx + right_idx) / 2;
          this.vpoints_vector[midpoint_index] = new Array(2);
          this.vpoints_vector[midpoint_index][0] = midpoint_x;
          this.vpoints_vector[midpoint_index][1] = midpoint_y;
          queue.push(new bound(left_idx, (right_idx + left_idx) / 2, iter + 1));
          queue.push(new bound((right_idx + left_idx) / 2, right_idx, iter + 1));
        }
      }
      x0 = this.vpoints_vector[0][0];
      y0 = this.vpoints_vector[0][1];
      max_y_idx = (this.vpoints_vector.length - 1) / 2 - 1;
      max_y = this.vpoints_vector[max_y_idx][1];
      max_y = this.height_offset;
      this.landscape = new Shape();
      this.img = new Image();
      this.img.src = "/img/LANDSCAPE/angry.png";
      this.img.onload = function() {
        var i, x1, x2, y1, y2, _i, _ref;
        _this.landscape.graphics.beginBitmapFill(_this.img);
        i = new Image();
        i.src = "/img/LANDSCAPE/grass-texture-0.png";
        _this.landscape.graphics.setStrokeStyle(8).beginBitmapStroke(i);
        _this.landscape.graphics.moveTo(x0, y0);
        for (i = _i = 1, _ref = _this.vpoints_vector.length - 2; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          x1 = _this.vpoints_vector[i][0];
          x2 = _this.vpoints_vector[i + 1][0];
          y1 = _this.vpoints_vector[i][1];
          y2 = _this.vpoints_vector[i + 1][1];
          if (i <= _this.flatLand || i >= _this.vpoints_vector.length - 1 - _this.flatLand) {
            y1 = _this.vpoints_vector[0][1];
            y2 = _this.vpoints_vector[0][1];
          }
          _this.landscape.graphics.lineTo(x2, y2);
          if (i === _this.vpoints_vector.length - 2) {
            _this.landscape.graphics.beginStroke(null);
            _this.landscape.graphics.moveTo(x2, y2);
            _this.landscape.graphics.lineTo(x2, _this.height);
            _this.landscape.graphics.lineTo(_this.vpoints_vector[0][0], _this.height);
            _this.landscape.graphics.lineTo(_this.vpoints_vector[0][0], _this.height_offset);
          }
        }
        return _this.easelStage.addChild(_this.landscape);
      };
      _results = [];
      for (i = _i = 0, _ref = this.vpoints_vector.length - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        x1 = this.vpoints_vector[i][0];
        x2 = this.vpoints_vector[i + 1][0];
        y1 = this.vpoints_vector[i][1];
        y2 = this.vpoints_vector[i + 1][1];
        if (i <= this.flatLand || i >= this.vpoints_vector.length - 2 - this.flatLand) {
          y1 = this.vpoints_vector[0][1];
          y2 = this.vpoints_vector[0][1];
        }
        _results.push(tinyRectangle = this.addEntity({
          whoami: "inefficient rectangle",
          bottom_left_corner: new Box2D.Common.Math.b2Vec2(x1, this.height),
          top_left_corner: new Box2D.Common.Math.b2Vec2(x1, y1),
          top_right_corner: new Box2D.Common.Math.b2Vec2(x2, y2),
          bottom_right_corner: new Box2D.Common.Math.b2Vec2(x2, this.height),
          type: options.type
        }));
      }
      return _results;
    };

    EaselBoxWorld.prototype.addBazooka = function(options) {
      var object;
      object = new EaselBoxBazooka(options);
      this.easelStage.addChild(object.easelObj);
      object.body = this.box2dWorld.CreateBody(object.bodyDef);
      object.body.CreateFixture(object.fixDef);
      object.setType('static');
      object.setState(options);
      this.objects.push(object);
      return object;
    };

    EaselBoxWorld.prototype.addBanana = function(options) {
      this.banana = new EaselBoxBanana(options);
      this.banana.body = this.box2dWorld.CreateBody(this.banana.bodyDef);
      this.banana.fixture = this.banana.body.CreateFixture(this.banana.fixDef);
      this.banana.setType('static');
      this.banana.setState(options);
      return this.objects.push(this.banana);
    };

    EaselBoxWorld.prototype.shootBanana = function(x, y, angle) {
      var force, position;
      if (!this.easelStage.contains(this.banana.easelObj)) {
        this.easelStage.addChild(this.banana.easelObj);
        this.banana.setState({
          xPixels: x,
          yPixels: y
        });
        this.banana.setType("dynamic");
        force = new Box2D.Common.Math.b2Vec2(Math.cos(angle) * 40, Math.sin(angle) * (-40));
        position = new Box2D.Common.Math.b2Vec2(this.banana.body.GetPosition().x, this.banana.body.GetPosition().y);
        return this.banana.body.ApplyImpulse(force, position);
      } else {
        return console.log("Already contained");
      }
    };

    EaselBoxWorld.prototype.addMonkey = function(options) {
      var object;
      object = new EaselBoxMonkey(this, options);
      this.easelStage.addChild(object.easelObj);
      object.headbody = this.box2dWorld.CreateBody(object.bodyDefHead);
      object.torsobody = this.box2dWorld.CreateBody(object.bodyDefTorso);
      object.lowerbodybody = this.box2dWorld.CreateBody(object.bodyDefLowerbody);
      object.headbodyfixture = object.headbody.CreateFixture(object.fixDefHead);
      object.torsobodyfixture = object.torsobody.CreateFixture(object.fixDefTorso);
      object.lowerbodybodyfixture = object.lowerbodybody.CreateFixture(object.fixDefLowerbody);
      object.setType('static');
      object.setState(options);
      this.objects.push(object);
      object.headtorsoweldJointDef.Initialize(object.headbody, object.torsobody, object.headbody.GetWorldCenter());
      object.torsolowerbodyweldJointDef.Initialize(object.torsobody, object.lowerbodybody, object.lowerbodybody.GetWorldCenter());
      this.box2dWorld.CreateJoint(object.headtorsoweldJointDef);
      this.box2dWorld.CreateJoint(object.torsolowerbodyweldJointDef);
      return object;
    };

    EaselBoxWorld.prototype.addTower = function(options) {
      var object;
      object = new EaselBoxBox(options);
      this.easelStage.addChild(object.easelObj);
      object.setState(options);
      this.objects.push(object);
      return object;
    };

    EaselBoxWorld.prototype.addArrow = function(options) {
      var object;
      object = new EaselBoxArrow(options);
      this.easelStage.addChild(object.easelObj);
      object.setState(options);
      this.objects.push(object);
      return object;
    };

    EaselBoxWorld.prototype.addEntity = function(options) {
      var object;
      object = null;
      if (options.whoami) {
        object = new EaselBoxLandscapeRectangle(options);
      } else if (options.radiusPixels) {
        object = new EaselBoxCircle(options.radiusPixels, options);
      } else {
        object = new EaselBoxRectangle(options.widthPixels, options.heightPixels, options);
      }
      this.easelStage.addChild(object.easelObj);
      object.body = this.box2dWorld.CreateBody(object.bodyDef);
      object.body.CreateFixture(object.fixDef);
      object.setType(options.type || 'dynamic');
      object.setState(options);
      this.objects.push(object);
      return object;
    };

    EaselBoxWorld.prototype.removeEntity = function(object) {
      this.box2dWorld.DestroyBody(object.body);
      return this.easelStage.removeChild(object.easelObj);
    };

    EaselBoxWorld.prototype.addImage = function(imgSrc, options) {
      var obj, property, value;
      obj = new Bitmap(imgSrc);
      for (property in options) {
        value = options[property];
        obj[property] = value;
      }
      return this.easelStage.addChild(obj);
    };

    EaselBoxWorld.prototype.tick = function() {
      var object, _i, _len, _ref;
      if (Ticker.getMeasuredFPS() > minFPS) {
        this.box2dWorld.Step(1 / Ticker.getMeasuredFPS(), 10, 10);
        this.box2dWorld.ClearForces();
        _ref = this.objects;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          object = _ref[_i];
          object.update();
        }
      }
      if (typeof this.callingObj.tick === 'function') {
        this.callingObj.tick();
      }
      this.easelStage.update();
      return this.box2dWorld.DrawDebugData();
    };

    return EaselBoxWorld;

  })();

  window.EaselBoxBox = (function() {
    var getType;

    function EaselBoxBox(options) {
      this.easelObj = new Bitmap(options.imgSrc);
      this.easelObj.x = options.xPixels;
      this.easelObj.y = options.yPixels;
      this.easelObj.scaleX = options.scaleX;
      this.easelObj.scaleY = options.scaleY;
    }

    EaselBoxBox.prototype.update = function() {};

    EaselBoxBox.prototype.setType = function(type) {};

    EaselBoxBox.prototype.setState = function(options) {
      var angleDegrees, angleRadians, angularVelDegrees, angularVelRadians, xMeters, xPixels, xVelMeters, xVelPixels, yMeters, yPixels, yVelMeters, yVelPixels;
      if (options && options.xPixels) {
        xPixels = options.xPixels;
        xMeters = xPixels / PIXELS_PER_METER;
      } else if (options && options.Xmeters) {
        xMeters = options.Xmeters;
        xPixels = xMeters * PIXELS_PER_METER;
      } else {
        xMeters = 0;
        xPixels = 0;
      }
      if (options && options.yPixels) {
        yPixels = options.yPixels;
        yMeters = yPixels / PIXELS_PER_METER;
      } else if (options && options.Xmeters) {
        yMeters = options.Ymeters;
        yPixels = YMeters * PIXELS_PER_METER;
      } else {
        yMeters = 0;
        yPixels = 0;
      }
      if (options && options.xVelPixels) {
        xVelPixels = options.xVelPixels;
        xVelMeters = xVelPixels / PIXELS_PER_METER;
      } else if (options && options.xVelMeters) {
        xVelMeters = options.xVelMeters;
        xVelPixels = xVelMeters * PIXELS_PER_METER;
      } else {
        xVelMeters = 0;
        xVelPixels = 0;
      }
      if (options && options.yVelPixels) {
        yVelPixels = options.yVelPixels;
        yVelMeters = yVelPixels / PIXELS_PER_METER;
      } else if (options && options.yVelMeters) {
        yVelMeters = options.yVelMeters;
        yVelPixels = yVelMeters * PIXELS_PER_METER;
      } else {
        yVelMeters = 0;
        yVelPixels = 0;
      }
      if (options && options.angleDegrees) {
        angleDegrees = options.angleDegrees;
        angleRadians = Math.PI * angleDegrees / 180;
      } else if (options && options.angleRadians) {
        angleRadians = options.angleRadians;
        angleDegrees = 180 * angleRadians / Math.PI;
      } else {
        angleRadians = 0;
        angleDegrees = 0;
      }
      if (options && options.angularVelRadians) {
        angularVelRadians = options.angularVelRadians;
        angularVelDegrees = 180 * angularVelRadians / Math.PI;
      } else if (options && options.angularVelDegrees) {
        angularVelDegrees = options.angularVelDegrees;
        angularVelRadians = Math.PI * angularVelDegrees / 180;
      } else {
        angularVelDegrees = 0;
        angularVelRadians = 0;
      }
      this.easelObj.x = xPixels;
      this.easelObj.y = yPixels;
      return this.easelObj.rotation = angleDegrees;
    };

    getType = function(type) {};

    return EaselBoxBox;

  })();

  window.EaselBoxBanana = (function() {
    var getType;

    function EaselBoxBanana(options) {
      var box2dShape, density, friction, restitution;
      this.easelObj = new Bitmap(options.imgSrc);
      this.easelObj.globalRegX = options.xPixels;
      this.easelObj.globalRegY = options.yPixels;
      this.easelObj.scaleX = options.scaleX;
      this.easelObj.scaleY = options.scaleY;
      this.easelObj.regX = options.regX;
      this.easelObj.regY = options.regY;
      box2dShape = new Box2D.Collision.Shapes.b2PolygonShape.AsBox((options.width / PIXELS_PER_METER) / 2, (options.height / PIXELS_PER_METER) / 2);
      density = (options && options.density) || 1;
      friction = (options && options.friction) || 0.5;
      restitution = (options && options.restitution) || 0.2;
      this.fixDef = new Box2D.Dynamics.b2FixtureDef;
      this.fixDef.density = density;
      this.fixDef.friction = friction;
      this.fixDef.restitution = restitution;
      this.fixDef.shape = box2dShape;
      this.bodyDef = new Box2D.Dynamics.b2BodyDef;
      this.body = null;
    }

    EaselBoxBanana.prototype.update = function() {
      this.easelObj.x = this.body.GetPosition().x * PIXELS_PER_METER;
      this.easelObj.y = (this.body.GetPosition().y) * PIXELS_PER_METER;
      return this.easelObj.rotation = this.body.GetAngle() * (180 / Math.PI);
    };

    EaselBoxBanana.prototype.setType = function(type) {
      return this.body.SetType(getType(type));
    };

    EaselBoxBanana.prototype.setState = function(options) {
      var angleDegrees, angleRadians, angularVelDegrees, angularVelRadians, xMeters, xPixels, xVelMeters, xVelPixels, yMeters, yPixels, yVelMeters, yVelPixels;
      if (options && options.xPixels) {
        xPixels = options.xPixels;
        xMeters = xPixels / PIXELS_PER_METER;
      } else if (options && options.Xmeters) {
        xMeters = options.Xmeters;
        xPixels = xMeters * PIXELS_PER_METER;
      } else {
        xMeters = 0;
        xPixels = 0;
      }
      if (options && options.yPixels) {
        yPixels = options.yPixels;
        yMeters = yPixels / PIXELS_PER_METER;
      } else if (options && options.Xmeters) {
        yMeters = options.Ymeters;
        yPixels = YMeters * PIXELS_PER_METER;
      } else {
        yMeters = 0;
        yPixels = 0;
      }
      if (options && options.xVelPixels) {
        xVelPixels = options.xVelPixels;
        xVelMeters = xVelPixels / PIXELS_PER_METER;
      } else if (options && options.xVelMeters) {
        xVelMeters = options.xVelMeters;
        xVelPixels = xVelMeters * PIXELS_PER_METER;
      } else {
        xVelMeters = 0;
        xVelPixels = 0;
      }
      if (options && options.yVelPixels) {
        yVelPixels = options.yVelPixels;
        yVelMeters = yVelPixels / PIXELS_PER_METER;
      } else if (options && options.yVelMeters) {
        yVelMeters = options.yVelMeters;
        yVelPixels = yVelMeters * PIXELS_PER_METER;
      } else {
        yVelMeters = 0;
        yVelPixels = 0;
      }
      if (options && options.angleDegrees) {
        angleDegrees = options.angleDegrees;
        angleRadians = Math.PI * angleDegrees / 180;
      } else if (options && options.angleRadians) {
        angleRadians = options.angleRadians;
        angleDegrees = 180 * angleRadians / Math.PI;
      } else {
        angleRadians = 0;
        angleDegrees = 0;
      }
      if (options && options.angularVelRadians) {
        angularVelRadians = options.angularVelRadians;
        angularVelDegrees = 180 * angularVelRadians / Math.PI;
      } else if (options && options.angularVelDegrees) {
        angularVelDegrees = options.angularVelDegrees;
        angularVelRadians = Math.PI * angularVelDegrees / 180;
      } else {
        angularVelDegrees = 0;
        angularVelRadians = 0;
      }
      this.easelObj.x = xPixels;
      this.easelObj.y = yPixels;
      this.easelObj.rotation = angleDegrees;
      this.body.GetPosition().x = xMeters;
      this.body.GetPosition().y = yMeters;
      this.body.SetAngle(angleRadians);
      this.body.SetAngularVelocity(angularVelRadians);
      return this.body.SetLinearVelocity(new Box2D.Common.Math.b2Vec2(xVelMeters, yVelMeters));
    };

    getType = function(type) {
      if ('dynamic' === type) {
        return Box2D.Dynamics.b2Body.b2_dynamicBody;
      } else if ('static' === type) {
        return Box2D.Dynamics.b2Body.b2_staticBody;
      } else if ('kinematic' === type) {
        return Box2D.Dynamics.b2Body.b2_kinematicBody;
      }
    };

    return EaselBoxBanana;

  })();

  window.EaselBoxContactListener = (function(_super) {
    var MyContact;

    __extends(EaselBoxContactListener, _super);

    MyContact = (function() {

      function MyContact(fixtureA, fixtureB) {
        this.fixtureA = fixtureA;
        this.fixtureB = fixtureB;
      }

      return MyContact;

    })();

    function EaselBoxContactListener() {
      this.contacts = [];
    }

    EaselBoxContactListener.prototype.BeginContact = function(contact) {
      var mycontact;
      mycontact = new MyContact(contact.GetFixtureA(), contact.GetFixtureB());
      return this.contacts.push(mycontact);
    };

    EaselBoxContactListener.prototype.EndContact = function(contact) {
      var endcontact, i, index, _i, _len, _ref;
      endcontact = new MyContact(contact.GetFixtureA(), contact.GetFixtureB());
      index = 0;
      _ref = this.contacts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        if (endcontact.fixtureA === i.fixtureA && endcontact.fixtureB === i.fixtureB) {
          break;
        }
        index++;
      }
      if (index >= 0) {
        return this.contacts.splice(index, 1);
      }
    };

    return EaselBoxContactListener;

  })(Box2D.Dynamics.b2ContactListener);

}).call(this);
