// Generated by CoffeeScript 1.3.3
(function() {
  var PIXELS_PER_METER,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.EaselBoxObject = (function() {
    var getType;

    function EaselBoxObject(easelObj, box2dShape, options) {
      var density, friction, restitution;
      this.easelObj = easelObj;
      density = (options && options.density) || 1;
      friction = (options && options.friction) || 0.5;
      restitution = (options && options.restitution) || 0.2;
      this.fixDef = new Box2D.Dynamics.b2FixtureDef;
      this.fixDef.density = density;
      this.fixDef.friction = friction;
      this.fixDef.restitution = restitution;
      this.fixDef.shape = box2dShape;
      this.bodyDef = new Box2D.Dynamics.b2BodyDef;
      this.body = null;
    }

    EaselBoxObject.prototype.update = function() {
      this.easelObj.x = this.body.GetPosition().x * PIXELS_PER_METER;
      this.easelObj.y = this.body.GetPosition().y * PIXELS_PER_METER;
      return this.easelObj.rotation = this.body.GetAngle() * (180 / Math.PI);
    };

    EaselBoxObject.prototype.setType = function(type) {
      return this.body.SetType(getType(type));
    };

    EaselBoxObject.prototype.setState = function(options) {
      var angleDegrees, angleRadians, angularVelDegrees, angularVelRadians, xMeters, xPixels, xVelMeters, xVelPixels, yMeters, yPixels, yVelMeters, yVelPixels;
      if (options && options.xPixels) {
        xPixels = options.xPixels;
        xMeters = xPixels / PIXELS_PER_METER;
      } else if (options && options.Xmeters) {
        xMeters = options.Xmeters;
        xPixels = xMeters * PIXELS_PER_METER;
      } else {
        xMeters = 0;
        xPixels = 0;
      }
      if (options && options.yPixels) {
        yPixels = options.yPixels;
        yMeters = yPixels / PIXELS_PER_METER;
      } else if (options && options.Xmeters) {
        yMeters = options.Ymeters;
        yPixels = YMeters * PIXELS_PER_METER;
      } else {
        yMeters = 0;
        yPixels = 0;
      }
      if (options && options.xVelPixels) {
        xVelPixels = options.xVelPixels;
        xVelMeters = xVelPixels / PIXELS_PER_METER;
      } else if (options && options.xVelMeters) {
        xVelMeters = options.xVelMeters;
        xVelPixels = xVelMeters * PIXELS_PER_METER;
      } else {
        xVelMeters = 0;
        xVelPixels = 0;
      }
      if (options && options.yVelPixels) {
        yVelPixels = options.yVelPixels;
        yVelMeters = yVelPixels / PIXELS_PER_METER;
      } else if (options && options.yVelMeters) {
        yVelMeters = options.yVelMeters;
        yVelPixels = yVelMeters * PIXELS_PER_METER;
      } else {
        yVelMeters = 0;
        yVelPixels = 0;
      }
      if (options && options.angleDegrees) {
        angleDegrees = options.angleDegrees;
        angleRadians = Math.PI * angleDegrees / 180;
      } else if (options && options.angleRadians) {
        angleRadians = options.angleRadians;
        angleDegrees = 180 * angleRadians / Math.PI;
      } else {
        angleRadians = 0;
        angleDegrees = 0;
      }
      if (options && options.angularVelRadians) {
        angularVelRadians = options.angularVelRadians;
        angularVelDegrees = 180 * angularVelRadians / Math.PI;
      } else if (options && options.angularVelDegrees) {
        angularVelDegrees = options.angularVelDegrees;
        angularVelRadians = Math.PI * angularVelDegrees / 180;
      } else {
        angularVelDegrees = 0;
        angularVelRadians = 0;
      }
      this.easelObj.x = xPixels;
      this.easelObj.y = yPixels;
      this.easelObj.rotation = angleDegrees;
      this.body.GetPosition().x = xMeters;
      this.body.GetPosition().y = yMeters;
      this.body.SetAngle(angleRadians);
      this.body.SetAngularVelocity(angularVelRadians);
      return this.body.SetLinearVelocity(new Box2D.Common.Math.b2Vec2(xVelMeters, yVelMeters));
    };

    getType = function(type) {
      if ('dynamic' === type) {
        return Box2D.Dynamics.b2Body.b2_dynamicBody;
      } else if ('static' === type) {
        return Box2D.Dynamics.b2Body.b2_staticBody;
      } else if ('kinematic' === type) {
        return Box2D.Dynamics.b2Body.b2_kinematicBody;
      }
    };

    return EaselBoxObject;

  })();

  window.EaselBoxCircle = (function(_super) {

    __extends(EaselBoxCircle, _super);

    function EaselBoxCircle(radiusPixels, options) {
      var bmpAnim, box2dShape, data, object, radiusMeters;
      if (radiusPixels == null) {
        radiusPixels = 20;
      }
      if (options == null) {
        options = null;
      }
      radiusMeters = radiusPixels / PIXELS_PER_METER;
      box2dShape = new Box2D.Collision.Shapes.b2CircleShape(radiusMeters);
      object = null;
      if (options && options.imgSrc) {
        if (options && options.frames) {
          data = {
            images: [options.imgSrc],
            frames: options.frames
          };
          bmpAnim = new BitmapAnimation(new SpriteSheet(data));
          object = bmpAnim.clone();
          object.gotoAndPlay(options.startFrame | 0);
        } else {
          object = new Bitmap(options.imgSrc);
        }
        object.scaleX = options.scaleX || 1;
        object.scaleY = options.scaleY || 1;
        object.regX = radiusPixels;
        object.regY = radiusPixels;
      } else {
        object = new Shape();
        object.graphics.beginRadialGradientFill(["#F00", "#00F"], [0.1, .9], 0, 0, 0, 0, 0, radiusPixels).drawCircle(0, 0, radiusPixels).beginFill("#FFF").drawRect(0, -1, radiusPixels, 2);
      }
      EaselBoxCircle.__super__.constructor.call(this, object, box2dShape, options);
    }

    return EaselBoxCircle;

  })(EaselBoxObject);

  window.EaselBoxRectangle = (function(_super) {

    __extends(EaselBoxRectangle, _super);

    function EaselBoxRectangle(widthPixels, heightPixels, options) {
      var bmpAnim, box2dShape, data, heightMeters, object, widthMeters;
      if (options == null) {
        options = null;
      }
      widthMeters = widthPixels / PIXELS_PER_METER;
      heightMeters = heightPixels / PIXELS_PER_METER;
      box2dShape = new Box2D.Collision.Shapes.b2PolygonShape.AsBox(widthMeters / 2, heightMeters / 2);
      object = null;
      if (options && options.imgSrc) {
        if (options && options.frames) {
          data = {
            images: [options.imgSrc],
            frames: options.frames
          };
          bmpAnim = new BitmapAnimation(new SpriteSheet(data));
          object = bmpAnim.clone();
          object.gotoAndPlay(options.startFrame | 0);
        } else {
          object = new Bitmap(options.imgSrc);
        }
        object.regX = widthPixels / 2;
        object.regY = heightPixels / 2;
      } else {
        object = new Shape();
        object.graphics.beginLinearGradientFill(["#F00", "#00F"], [0, 0.5], -widthPixels / 2, 0, widthPixels, 0).drawRect(-widthPixels / 2, -heightPixels / 2, widthPixels, heightPixels);
      }
      EaselBoxRectangle.__super__.constructor.call(this, object, box2dShape, options);
    }

    return EaselBoxRectangle;

  })(EaselBoxObject);

  window.EaselBoxLandscapeRectangle = (function(_super) {

    __extends(EaselBoxLandscapeRectangle, _super);

    function EaselBoxLandscapeRectangle(options) {
      var box2dShape, hillVector, object, x1, x2, x3, x4, y1, y2, y3, y4;
      object = new Shape();
      hillVector = new Vector(4);
      x1 = options.bottom_left_corner.x / PIXELS_PER_METER;
      y1 = options.bottom_left_corner.y / PIXELS_PER_METER;
      x2 = options.top_left_corner.x / PIXELS_PER_METER;
      y2 = options.top_left_corner.y / PIXELS_PER_METER;
      x3 = options.top_right_corner.x / PIXELS_PER_METER;
      y3 = options.top_right_corner.y / PIXELS_PER_METER;
      x4 = options.bottom_right_corner.x / PIXELS_PER_METER;
      y4 = options.bottom_right_corner.y / PIXELS_PER_METER;
      hillVector[0] = new Box2D.Common.Math.b2Vec2(x1, y1);
      hillVector[1] = new Box2D.Common.Math.b2Vec2(x2, y2);
      hillVector[2] = new Box2D.Common.Math.b2Vec2(x3, y3);
      hillVector[3] = new Box2D.Common.Math.b2Vec2(x4, y4);
      box2dShape = new Box2D.Collision.Shapes.b2PolygonShape.AsArray(hillVector, 4);
      EaselBoxLandscapeRectangle.__super__.constructor.call(this, object, box2dShape, options);
    }

    return EaselBoxLandscapeRectangle;

  })(EaselBoxObject);

  window.EaselBoxMonkey = (function() {
    var getType;

    function EaselBoxMonkey(options) {
      var density, friction, restitution,
        _this = this;
      this.spriteSheet = options.SpriteSheet;
      this.bmpAnimationStandBy = new BitmapAnimation(this.spriteSheet);
      this.bmpAnimationStandBy.gotoAndPlay("standby");
      this.bmpAnimationStandBy.name = "monkey_idle";
      this.bmpAnimationStandBy.currentFrame = 0;
      this.easelObj = this.bmpAnimationStandBy;
      this.easelObj.regX = options.regX;
      this.easelObj.regY = options.regY;
      this.easelObj.scaleX = options.scaleX;
      this.easelObj.scaleY = options.scaleY;
      this.size_head_meters = options.size_head / PIXELS_PER_METER;
      this.size_torso_meters = options.size_torso / PIXELS_PER_METER;
      this.size_lowerbody_meters = options.size_lowerbody / PIXELS_PER_METER;
      this.monkeyhead = new Box2D.Collision.Shapes.b2PolygonShape.AsBox(this.size_head_meters, this.size_head_meters);
      this.monkeytorso = new Box2D.Collision.Shapes.b2PolygonShape.AsBox(this.size_torso_meters, this.size_torso_meters);
      this.monkeylowerbody = new Box2D.Collision.Shapes.b2PolygonShape.AsBox(this.size_lowerbody_meters, this.size_lowerbody_meters);
      density = (options && options.density) || 1;
      friction = (options && options.friction) || 0.5;
      restitution = (options && options.restitution) || 0.2;
      this.fixDefHead = new Box2D.Dynamics.b2FixtureDef;
      this.fixDefHead.density = density;
      this.fixDefHead.friction = friction;
      this.fixDefHead.restitution = restitution;
      this.fixDefHead.shape = this.monkeyhead;
      this.bodyDefHead = new Box2D.Dynamics.b2BodyDef;
      this.headbody = null;
      this.fixDefTorso = new Box2D.Dynamics.b2FixtureDef;
      this.fixDefTorso.density = density;
      this.fixDefTorso.friction = friction;
      this.fixDefTorso.restitution = restitution;
      this.fixDefTorso.shape = this.monkeytorso;
      this.bodyDefTorso = new Box2D.Dynamics.b2BodyDef;
      this.torsobody = null;
      this.fixDefLowerbody = new Box2D.Dynamics.b2FixtureDef;
      this.fixDefLowerbody.density = density;
      this.fixDefLowerbody.friction = friction;
      this.fixDefLowerbody.restitution = restitution;
      this.fixDefLowerbody.shape = this.monkeylowerbody;
      this.bodyDefLowerbody = new Box2D.Dynamics.b2BodyDef;
      this.lowerbodybody = null;
      this.headtorsoweldJointDef = new Box2D.Dynamics.Joints.b2WeldJointDef();
      this.torsolowerbodyweldJointDef = new Box2D.Dynamics.Joints.b2WeldJointDef();
      this.easelObj.onPress = function(eventPress) {
        _this.easelObj.pressedX = eventPress.stageX;
        _this.easelObj.pressedY = eventPress.stageY;
        return eventPress.onMouseMove = function(event) {
          var deltaX, deltaY;
          deltaX = event.stageX - _this.easelObj.pressedX;
          deltaY = event.stageY - _this.easelObj.pressedY;
          _this.setState({
            xPixels: _this.easelObj.x + deltaX,
            yPixels: _this.easelObj.y + deltaY
          });
          _this.easelObj.pressedX = event.stageX;
          return _this.easelObj.pressedY = event.stageY;
        };
      };
    }

    EaselBoxMonkey.prototype.update = function() {
      this.easelObj.x = this.torsobody.GetPosition().x * PIXELS_PER_METER;
      this.easelObj.y = this.torsobody.GetPosition().y * PIXELS_PER_METER;
      return this.easelObj.rotation = this.torsobody.GetAngle() * (180 / Math.PI);
    };

    EaselBoxMonkey.prototype.ApplyForce = function(worldgravity) {
      this.headbody.ApplyForce(this.headbody.GetMass() * -worldgravity, this.headbody.GetWorldCenter());
      this.torsobody.ApplyForce(this.torsobody.GetMass() * -worldgravity, this.torsobody.GetWorldCenter());
      return this.lowerbodybody.ApplyForce(this.lowerbodybody.GetMass() * -worldgravity, this.lowerbodybody.GetWorldCenter());
    };

    EaselBoxMonkey.prototype.setType = function(type) {
      this.headbody.SetType(getType(type));
      this.torsobody.SetType(getType(type));
      return this.lowerbodybody.SetType(getType(type));
    };

    EaselBoxMonkey.prototype.setState = function(options) {
      var angleDegrees, angleRadians, angularVelDegrees, angularVelRadians, xMeters, xPixels, xVelMeters, xVelPixels, yMeters, yPixels, yVelMeters, yVelPixels;
      if (options && options.xPixels) {
        xPixels = options.xPixels;
        xMeters = xPixels / PIXELS_PER_METER;
      } else if (options && options.Xmeters) {
        xMeters = options.Xmeters;
        xPixels = xMeters * PIXELS_PER_METER;
      } else {
        xMeters = 0;
        xPixels = 0;
      }
      if (options && options.yPixels) {
        yPixels = options.yPixels;
        yMeters = yPixels / PIXELS_PER_METER;
      } else if (options && options.Xmeters) {
        yMeters = options.Ymeters;
        yPixels = YMeters * PIXELS_PER_METER;
      } else {
        yMeters = 0;
        yPixels = 0;
      }
      if (options && options.xVelPixels) {
        xVelPixels = options.xVelPixels;
        xVelMeters = xVelPixels / PIXELS_PER_METER;
      } else if (options && options.xVelMeters) {
        xVelMeters = options.xVelMeters;
        xVelPixels = xVelMeters * PIXELS_PER_METER;
      } else {
        xVelMeters = 0;
        xVelPixels = 0;
      }
      if (options && options.yVelPixels) {
        yVelPixels = options.yVelPixels;
        yVelMeters = yVelPixels / PIXELS_PER_METER;
      } else if (options && options.yVelMeters) {
        yVelMeters = options.yVelMeters;
        yVelPixels = yVelMeters * PIXELS_PER_METER;
      } else {
        yVelMeters = 0;
        yVelPixels = 0;
      }
      if (options && options.angleDegrees) {
        angleDegrees = options.angleDegrees;
        angleRadians = Math.PI * angleDegrees / 180;
      } else if (options && options.angleRadians) {
        angleRadians = options.angleRadians;
        angleDegrees = 180 * angleRadians / Math.PI;
      } else {
        angleRadians = 0;
        angleDegrees = 0;
      }
      if (options && options.angularVelRadians) {
        angularVelRadians = options.angularVelRadians;
        angularVelDegrees = 180 * angularVelRadians / Math.PI;
      } else if (options && options.angularVelDegrees) {
        angularVelDegrees = options.angularVelDegrees;
        angularVelRadians = Math.PI * angularVelDegrees / 180;
      } else {
        angularVelDegrees = 0;
        angularVelRadians = 0;
      }
      this.easelObj.x = xPixels;
      this.easelObj.y = yPixels;
      this.easelObj.rotation = angleDegrees;
      this.headbody.GetPosition().x = xMeters;
      this.headbody.GetPosition().y = yMeters - this.size_torso_meters - this.size_head_meters - 0.1;
      this.headbody.SetAngle(angleRadians);
      this.headbody.SetAngularVelocity(angularVelRadians);
      this.headbody.SetLinearVelocity(new Box2D.Common.Math.b2Vec2(xVelMeters, yVelMeters));
      this.torsobody.GetPosition().x = xMeters;
      this.torsobody.GetPosition().y = yMeters;
      this.torsobody.SetAngle(angleRadians);
      this.torsobody.SetAngularVelocity(angularVelRadians);
      this.torsobody.SetLinearVelocity(new Box2D.Common.Math.b2Vec2(xVelMeters, yVelMeters));
      this.lowerbodybody.GetPosition().x = xMeters;
      this.lowerbodybody.GetPosition().y = yMeters + this.size_torso_meters + this.size_lowerbody_meters + 0.1;
      this.lowerbodybody.SetAngle(angleRadians);
      this.lowerbodybody.SetAngularVelocity(angularVelRadians);
      return this.lowerbodybody.SetLinearVelocity(new Box2D.Common.Math.b2Vec2(xVelMeters, yVelMeters));
    };

    getType = function(type) {
      if ('dynamic' === type) {
        return Box2D.Dynamics.b2Body.b2_dynamicBody;
      } else if ('static' === type) {
        return Box2D.Dynamics.b2Body.b2_staticBody;
      } else if ('kinematic' === type) {
        return Box2D.Dynamics.b2Body.b2_kinematicBody;
      }
    };

    return EaselBoxMonkey;

  })();

  window.EaselBoxArrow = (function() {
    var getType;

    function EaselBoxArrow(options) {
      var _this = this;
      this.x1 = options.shape_coordinates[0];
      this.y1 = options.shape_coordinates[1];
      this.x2 = options.shape_coordinates[2];
      this.y2 = options.shape_coordinates[3];
      this.x3 = options.shape_coordinates[4];
      this.y3 = options.shape_coordinates[5];
      this.x4 = options.shape_coordinates[6];
      this.y4 = options.shape_coordinates[7];
      this.x5 = options.shape_coordinates[8];
      this.y5 = options.shape_coordinates[9];
      this.x6 = options.shape_coordinates[10];
      this.y6 = options.shape_coordinates[11];
      this.rotation = options.rotation | 0;
      if (options.imgSrc) {
        this.easelObj = new Bitmap(options.imgSrc);
      } else {
        this.easelObj = new Shape();
        this.easelObj.REGX = 0;
        this.easelObj.REGY = 0;
        this.drawme();
      }
      this.easelObj.onPress = function(eventPress) {
        _this.rotateme(30);
        eventPress.onMouseMove = function(event) {};
        return eventPress.onMouseUp = function(event) {};
      };
    }

    EaselBoxArrow.prototype.drawme = function(xPixels, yPixels) {
      this.easelObj.regX = this.easelObj.REGX;
      this.easelObj.regY = this.easelObj.REGY;
      console.log(this.x1 + ":" + this.y1 + ":" + this.x2 + ":" + this.y2 + ":" + this.x3 + ":" + this.y3 + ":" + this.x4 + ":" + this.y4 + ":" + this.x5 + ":" + this.y5 + ":" + this.x6 + ":" + this.y6);
      this.easelObj.graphics.clear();
      this.easelObj.graphics.beginFill("pink");
      this.easelObj.graphics.moveTo(this.x1, this.y1);
      this.easelObj.graphics.lineTo(this.x2, this.y2);
      this.easelObj.graphics.lineTo(this.x3, this.y3);
      this.easelObj.graphics.lineTo(this.x4, this.y4);
      this.easelObj.graphics.lineTo(this.x5, this.y5);
      this.easelObj.graphics.lineTo(this.x6, this.y6);
      this.easelObj.graphics.lineTo(this.x3, this.y3);
      this.easelObj.graphics.lineTo(this.x4, this.y4);
      this.easelObj.graphics.lineTo(this.x1, this.y1);
      return this.easelObj.setTransform(this.rotation);
    };

    EaselBoxArrow.prototype.rotateme = function(angleDegrees) {
      var computePointRotation, x2rotated, x3rotated, x4rotated, x5rotated, x6rotated;
      computePointRotation = function(x, y, x1, y1, angleDegrees) {
        var A, B, M, N, P, Z, point;
        point = (function() {

          function point() {
            this.x = 0;
            this.y = 0;
          }

          return point;

        })();
        A = Math.pow(x - x1, 2) + Math.pow(y1 - y, 2);
        B = 4 * Math.pow(Math.sin((angleDegrees / 2) * Math.PI / 180), 2) * A;
        M = -(B + y1 * y1 - y * y - A - Math.pow(x - x1, 2)) / 2;
        Z = 2 * y1 * Math.pow(x - x1, 2) + 2 * M * (y - y1);
        N = A * Math.pow(x - x1, 2) - M * M;
        P = N - y1 * y1 * Math.pow(x - x1, 2);
        point = new Point();
        point.y = (Z - Math.sqrt(Math.pow(Z, 2) + 4 * A * P)) / (2 * A);
        point.x = x1 + Math.sqrt(A - Math.pow(y1 - point.y, 2));
        return point;
      };
      x2rotated = computePointRotation(this.x2, this.y2, this.x1, this.y1, angleDegrees);
      x3rotated = computePointRotation(this.x3, this.y3, this.x1, this.y1, angleDegrees);
      x4rotated = computePointRotation(this.x4, this.y4, this.x1, this.y1, angleDegrees);
      x5rotated = computePointRotation(this.x5, this.y5, this.x1, this.y1, angleDegrees);
      x6rotated = computePointRotation(this.x6, this.y6, this.x1, this.y1, angleDegrees);
      this.x2 = x2rotated.x;
      this.y2 = x2rotated.y;
      this.x3 = x3rotated.x;
      this.y3 = x3rotated.y;
      this.x4 = x4rotated.x;
      this.y4 = x4rotated.y;
      this.x5 = x5rotated.x;
      this.y5 = x5rotated.y;
      this.x6 = x6rotated.x;
      this.y6 = x6rotated.y;
      console.log(this.x1 + ":" + this.y1 + ":" + this.x2 + ":" + this.y2 + ":" + this.x3 + ":" + this.y3 + ":" + this.x4 + ":" + this.y4 + ":" + this.x5 + ":" + this.y5 + ":" + this.x6 + ":" + this.y6);
      return this.drawme();
    };

    EaselBoxArrow.prototype.update = function() {
      this.easelObj.x = this.easelObj.x;
      this.easelObj.y = this.easelObj.y;
      return this.easelObj.rotation = this.easelObj.rotation;
    };

    EaselBoxArrow.prototype.setType = function(type) {};

    EaselBoxArrow.prototype.setState = function(options) {
      var angleDegrees, angleRadians, angularVelDegrees, angularVelRadians, xMeters, xPixels, xVelMeters, xVelPixels, yMeters, yPixels, yVelMeters, yVelPixels;
      if (options && options.xPixels) {
        xPixels = options.xPixels;
        xMeters = xPixels / PIXELS_PER_METER;
      } else if (options && options.Xmeters) {
        xMeters = options.Xmeters;
        xPixels = xMeters * PIXELS_PER_METER;
      } else {
        xMeters = 0;
        xPixels = 0;
      }
      if (options && options.yPixels) {
        yPixels = options.yPixels;
        yMeters = yPixels / PIXELS_PER_METER;
      } else if (options && options.Xmeters) {
        yMeters = options.Ymeters;
        yPixels = YMeters * PIXELS_PER_METER;
      } else {
        yMeters = 0;
        yPixels = 0;
      }
      if (options && options.xVelPixels) {
        xVelPixels = options.xVelPixels;
        xVelMeters = xVelPixels / PIXELS_PER_METER;
      } else if (options && options.xVelMeters) {
        xVelMeters = options.xVelMeters;
        xVelPixels = xVelMeters * PIXELS_PER_METER;
      } else {
        xVelMeters = 0;
        xVelPixels = 0;
      }
      if (options && options.yVelPixels) {
        yVelPixels = options.yVelPixels;
        yVelMeters = yVelPixels / PIXELS_PER_METER;
      } else if (options && options.yVelMeters) {
        yVelMeters = options.yVelMeters;
        yVelPixels = yVelMeters * PIXELS_PER_METER;
      } else {
        yVelMeters = 0;
        yVelPixels = 0;
      }
      if (options && options.angleDegrees) {
        angleDegrees = options.angleDegrees;
        angleRadians = Math.PI * angleDegrees / 180;
      } else if (options && options.angleRadians) {
        angleRadians = options.angleRadians;
        angleDegrees = 180 * angleRadians / Math.PI;
      } else {
        angleRadians = 0;
        angleDegrees = 0;
      }
      if (options && options.angularVelRadians) {
        angularVelRadians = options.angularVelRadians;
        angularVelDegrees = 180 * angularVelRadians / Math.PI;
      } else if (options && options.angularVelDegrees) {
        angularVelDegrees = options.angularVelDegrees;
        angularVelRadians = Math.PI * angularVelDegrees / 180;
      } else {
        angularVelDegrees = 0;
        angularVelRadians = 0;
      }
      this.easelObj.x = xPixels;
      this.easelObj.y = yPixels;
      return this.easelObj.rotation = angleDegrees;
    };

    getType = function(type) {};

    return EaselBoxArrow;

  })();

  PIXELS_PER_METER = 30;

  window.EaselBoxWorld = (function() {
    var minFPS;

    minFPS = 10;

    function EaselBoxWorld(callingObj, frameRate, canvas, debugCanvas, gravityX, gravityY, pixelsPerMeter) {
      var debugDraw;
      this.callingObj = callingObj;
      this.pixelsPerMeter = pixelsPerMeter;
      PIXELS_PER_METER = this.pixelsPerMeter;
      Ticker.addListener(this);
      Ticker.setFPS(frameRate);
      this.box2dWorld = new Box2D.Dynamics.b2World(new Box2D.Common.Math.b2Vec2(gravityX, gravityY), true);
      this.easelStage = new Stage(canvas);
      this.objects = [];
      debugDraw = new Box2D.Dynamics.b2DebugDraw();
      debugDraw.SetSprite(debugCanvas.getContext("2d"));
      debugDraw.SetDrawScale(this.pixelsPerMeter);
      debugDraw.SetFillAlpha(0.3);
      debugDraw.SetLineThickness(2.0);
      debugDraw.SetFlags(Box2D.Dynamics.b2DebugDraw.e_shapeBit | Box2D.Dynamics.b2DebugDraw.e_jointBit | Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit);
      this.box2dWorld.SetDebugDraw(debugDraw);
    }

    EaselBoxWorld.prototype.addLandscape = function(options) {
      var bound, firstElement, flatLand, height, height_offset, i, img, iter, iterations, left_idx, max, max_width, midpoint_index, midpoint_x, midpoint_y, min, min_width, object, queue, r, right_idx, ticks, tinyRectangle, vpoints_vector, x1, x2, y1, y2, _i, _j, _ref, _ref1;
      height_offset = options.vertical_offset;
      min_width = 0;
      max_width = options.width;
      iterations = options.iterations;
      r = options.smoothness;
      height = options.height;
      bound = (function() {

        function bound(min_idx, max_idx, iteration) {
          this.min_idx = min_idx;
          this.max_idx = max_idx;
          this.iteration = iteration;
        }

        return bound;

      })();
      min = -80;
      max = 50;
      ticks = Math.pow(2, iterations);
      vpoints_vector = new Array(ticks + 1);
      vpoints_vector[0] = new Array(2);
      vpoints_vector[ticks] = new Array(2);
      vpoints_vector[0][0] = min_width;
      vpoints_vector[0][1] = height_offset;
      vpoints_vector[ticks][0] = max_width;
      vpoints_vector[ticks][1] = height_offset;
      queue = new Array();
      queue.push(new bound(0, ticks, 1));
      while (queue.length > 0) {
        firstElement = queue.shift();
        left_idx = firstElement.min_idx;
        right_idx = firstElement.max_idx;
        iter = firstElement.iteration;
        if (right_idx - left_idx > 1) {
          midpoint_x = (vpoints_vector[right_idx][0] + vpoints_vector[left_idx][0]) / 2;
          midpoint_y = (vpoints_vector[right_idx][1] + vpoints_vector[left_idx][1]) / 2;
          if (iter > 1) {
            min = min * Math.pow(2, -r);
            max = max * Math.pow(2, -r);
          }
          if (iter === 1) {
            midpoint_y = midpoint_y + Math.random() * (-100 - 5 * min) + 5 * min;
          } else {
            midpoint_y = midpoint_y + Math.random() * (max - min) + min;
          }
          midpoint_index = (left_idx + right_idx) / 2;
          vpoints_vector[midpoint_index] = new Array(2);
          vpoints_vector[midpoint_index][0] = midpoint_x;
          vpoints_vector[midpoint_index][1] = midpoint_y;
          queue.push(new bound(left_idx, (right_idx + left_idx) / 2, iter + 1));
          queue.push(new bound((right_idx + left_idx) / 2, right_idx, iter + 1));
        }
      }
      flatLand = 18;
      for (i = _i = 0, _ref = vpoints_vector.length - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        x1 = vpoints_vector[i][0];
        x2 = vpoints_vector[i + 1][0];
        y1 = vpoints_vector[i][1];
        y2 = vpoints_vector[i + 1][1];
        if (i <= flatLand) {
          y1 = vpoints_vector[0][1];
          y2 = vpoints_vector[0][1];
        }
        tinyRectangle = this.addEntity({
          whoami: "inefficient rectangle",
          bottom_left_corner: new Box2D.Common.Math.b2Vec2(x1, height),
          top_left_corner: new Box2D.Common.Math.b2Vec2(x1, y1),
          top_right_corner: new Box2D.Common.Math.b2Vec2(x2, y2),
          bottom_right_corner: new Box2D.Common.Math.b2Vec2(x2, height),
          type: options.type
        });
      }
      object = new Shape();
      img = new Image();
      img.src = "/img/LANDSCAPE/snapshot.png";
      object.graphics.beginBitmapFill(img);
      object.graphics.moveTo(vpoints_vector[0][0], vpoints_vector[0][1]);
      for (i = _j = 1, _ref1 = vpoints_vector.length - 2; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
        x1 = vpoints_vector[i][0];
        x2 = vpoints_vector[i + 1][0];
        y1 = vpoints_vector[i][1];
        y2 = vpoints_vector[i + 1][1];
        object.graphics.lineTo(x2, y2);
        if (i === vpoints_vector.length - 2) {
          object.graphics.lineTo(x2, height);
          object.graphics.lineTo(vpoints_vector[0][0], height);
          object.graphics.lineTo(vpoints_vector[0][0], height_offset);
        }
      }
      return this.easelStage.addChild(object);
    };

    EaselBoxWorld.prototype.addMonkey = function(options) {
      var object;
      object = new EaselBoxMonkey(options);
      this.easelStage.addChild(object.easelObj);
      object.headbody = this.box2dWorld.CreateBody(object.bodyDefHead);
      object.torsobody = this.box2dWorld.CreateBody(object.bodyDefTorso);
      object.lowerbodybody = this.box2dWorld.CreateBody(object.bodyDefLowerbody);
      object.headbody.CreateFixture(object.fixDefHead);
      object.torsobody.CreateFixture(object.fixDefTorso);
      object.lowerbodybody.CreateFixture(object.fixDefLowerbody);
      object.setType('static');
      object.setState(options);
      this.objects.push(object);
      object.headtorsoweldJointDef.Initialize(object.headbody, object.torsobody, object.headbody.GetWorldCenter());
      object.torsolowerbodyweldJointDef.Initialize(object.torsobody, object.lowerbodybody, object.lowerbodybody.GetWorldCenter());
      this.box2dWorld.CreateJoint(object.headtorsoweldJointDef);
      this.box2dWorld.CreateJoint(object.torsolowerbodyweldJointDef);
      return object;
    };

    EaselBoxWorld.prototype.addArrow = function(options) {
      var object;
      object = new EaselBoxArrow(options);
      this.easelStage.addChild(object.easelObj);
      object.setState(options);
      this.objects.push(object);
      return object;
    };

    EaselBoxWorld.prototype.addEntity = function(options) {
      var object;
      object = null;
      if (options.whoami) {
        object = new EaselBoxLandscapeRectangle(options);
      } else if (options.radiusPixels) {
        object = new EaselBoxCircle(options.radiusPixels, options);
      } else {
        object = new EaselBoxRectangle(options.widthPixels, options.heightPixels, options);
      }
      this.easelStage.addChild(object.easelObj);
      object.body = this.box2dWorld.CreateBody(object.bodyDef);
      object.body.CreateFixture(object.fixDef);
      object.setType(options.type || 'dynamic');
      object.setState(options);
      this.objects.push(object);
      return object;
    };

    EaselBoxWorld.prototype.removeEntity = function(object) {
      this.box2dWorld.DestroyBody(object.body);
      return this.easelStage.removeChild(object.easelObj);
    };

    EaselBoxWorld.prototype.addImage = function(imgSrc, options) {
      var obj, property, value;
      obj = new Bitmap(imgSrc);
      for (property in options) {
        value = options[property];
        obj[property] = value;
      }
      return this.easelStage.addChild(obj);
    };

    EaselBoxWorld.prototype.tick = function() {
      var object, _i, _len, _ref;
      if (Ticker.getMeasuredFPS() > minFPS) {
        this.box2dWorld.Step(1 / Ticker.getMeasuredFPS(), 10, 10);
        this.box2dWorld.ClearForces();
        _ref = this.objects;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          object = _ref[_i];
          object.update();
        }
      }
      if (typeof this.callingObj.tick === 'function') {
        this.callingObj.tick();
      }
      this.easelStage.update();
      return this.box2dWorld.DrawDebugData();
    };

    EaselBoxWorld.prototype.vector = function(x, y) {
      return new Box2D.Common.Math.b2Vec2(x, y);
    };

    return EaselBoxWorld;

  })();

}).call(this);
